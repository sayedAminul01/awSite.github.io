<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laser Defense - AlienWeb Games</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: radial-gradient(circle at center, #0a0a2e 0%, #000 100%);
            color: #fff; font-family: 'Orbitron', sans-serif;
            display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 10px;
        }
        
        .ad-banner {
            width: 100%; max-width: 728px; height: 90px; background: rgba(255, 0, 0, 0.1);
            border: 1px dashed #ff0000; display: flex; align-items: center; justify-content: center;
            margin: 10px 0; border-radius: 5px; font-size: 12px; opacity: 0.7;
        }
        
        .header { text-align: center; margin-bottom: 15px; }
        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem); background: linear-gradient(45deg, #ff0000, #ff6600);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 5px; text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        
        .stats { display: flex; gap: 20px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center; }
        .stat {
            background: rgba(255, 0, 0, 0.2); padding: 8px 16px; border-radius: 8px;
            border: 1px solid #ff0000; font-weight: bold;
        }
        
        #gameContainer { position: relative; margin-bottom: 15px; }
        
        #gameCanvas {
            border: 3px solid #ff0000; background: #000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5); border-radius: 10px; cursor: crosshair;
        }
        
        .controls { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px; }
        
        .btn {
            background: linear-gradient(45deg, #ff0000, #ff6600); border: none;
            padding: 12px 24px; border-radius: 25px; color: #000; font-weight: bold;
            cursor: pointer; transition: all 0.3s ease; font-family: 'Orbitron', sans-serif;
        }
        
        .btn:hover { transform: scale(1.05); box-shadow: 0 5px 15px rgba(255, 0, 0, 0.4); }
        
        #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 15px;
            text-align: center; border: 2px solid #ff0000; display: none; z-index: 100;
        }
    </style>
</head>
<body>

<!--     Ads -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3056427584192481"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-3056427584192481"
     data-ad-slot="8067325454"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


    
    <div class="header">
        <h1>ðŸ”« Laser Defense</h1>
        <p>Ultimate tower defense with laser cannons!</p>
    </div>
    
    <div class="stats">
        <div class="stat">Wave: <span id="wave">1</span></div>
        <div class="stat">Lives: <span id="lives">20</span></div>
        <div class="stat">Money: $<span id="money">100</span></div>
        <div class="stat">Score: <span id="score">0</span></div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="finalWave">0</span></p>
            <button class="btn" onclick="restartGame()">Play Again</button>
            <button class="btn" onclick="window.location.href='index.html'">Back to Menu</button>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn" onclick="selectTower('basic')" id="basicBtn">Basic Tower ($50)</button>
        <button class="btn" onclick="selectTower('laser')" id="laserBtn">Laser Tower ($100)</button>
        <button class="btn" onclick="selectTower('missile')" id="missileBtn">Missile Tower ($150)</button>
        <button class="btn" onclick="toggleSound()" id="soundBtn">ðŸ”Š Sound ON</button>
    </div>
    
  

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let audioContext, soundEnabled = true;
        
        function createSound(freq, dur, type = 'sine', vol = 0.1) {
            if (!soundEnabled || !audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain); gain.connect(audioContext.destination);
            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
            osc.type = type;
            gain.gain.setValueAtTime(vol, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + dur);
            osc.start(audioContext.currentTime);
            osc.stop(audioContext.currentTime + dur);
        }
        
        function playSound(type) {
            switch(type) {
                case 'shoot': createSound(800, 0.1, 'square', 0.2); break;
                case 'hit': createSound(300, 0.2, 'sawtooth', 0.3); break;
                case 'place': createSound(440, 0.1, 'sine', 0.2); break;
                case 'wave': createSound(200, 0.5, 'triangle', 0.3); break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? 'ðŸ”Š Sound ON' : 'ðŸ”‡ Sound OFF';
            if (soundEnabled && !audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        document.addEventListener('click', () => {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }, { once: true });
        
        let gameState = { wave: 1, lives: 20, money: 100, score: 0, running: true, selectedTower: null };
        let path = [], towers = [], enemies = [], projectiles = [], particles = [];
        
        // Create path
        function createPath() {
            path = [
                {x: -50, y: 300}, {x: 100, y: 300}, {x: 100, y: 150}, {x: 300, y: 150},
                {x: 300, y: 450}, {x: 500, y: 450}, {x: 500, y: 100}, {x: 700, y: 100},
                {x: 700, y: 350}, {x: 850, y: 350}
            ];
        }
        
        function selectTower(type) {
            const costs = { basic: 50, laser: 100, missile: 150 };
            if (gameState.money >= costs[type]) {
                gameState.selectedTower = type;
                document.querySelectorAll('.btn').forEach(btn => btn.style.background = 'linear-gradient(45deg, #ff0000, #ff6600)');
                document.getElementById(type + 'Btn').style.background = 'linear-gradient(45deg, #00ff00, #00cc00)';
            }
        }
        
        canvas.addEventListener('click', (e) => {
            if (!gameState.selectedTower) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Check if position is valid (not on path)
            let validPosition = true;
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i], p2 = path[i + 1];
                const dist = distanceToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                if (dist < 40) validPosition = false;
            }
            
            // Check if too close to other towers
            towers.forEach(tower => {
                if (Math.sqrt((x - tower.x)**2 + (y - tower.y)**2) < 60) validPosition = false;
            });
            
            if (validPosition) {
                const costs = { basic: 50, laser: 100, missile: 150 };
                const cost = costs[gameState.selectedTower];
                
                if (gameState.money >= cost) {
                    towers.push({
                        x, y, type: gameState.selectedTower,
                        range: gameState.selectedTower === 'missile' ? 150 : 100,
                        damage: gameState.selectedTower === 'basic' ? 25 : gameState.selectedTower === 'laser' ? 40 : 60,
                        fireRate: gameState.selectedTower === 'laser' ? 10 : 30,
                        lastFire: 0, target: null
                    });
                    
                    gameState.money -= cost;
                    playSound('place');
                    updateUI();
                }
            }
        });
        
        function distanceToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D, lenSq = C * C + D * D;
            const param = lenSq !== 0 ? dot / lenSq : -1;
            
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            
            return Math.sqrt((px - xx)**2 + (py - yy)**2);
        }
        
        function spawnWave() {
            const enemyCount = 5 + gameState.wave * 2;
            const enemyTypes = ['basic', 'fast', 'tank'];
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    enemies.push({
                        x: path[0].x, y: path[0].y, pathIndex: 0, progress: 0,
                        type, health: type === 'tank' ? 100 : type === 'fast' ? 30 : 50,
                        maxHealth: type === 'tank' ? 100 : type === 'fast' ? 30 : 50,
                        speed: type === 'fast' ? 2 : type === 'tank' ? 0.5 : 1,
                        reward: type === 'tank' ? 30 : type === 'fast' ? 15 : 20,
                        color: type === 'tank' ? '#666' : type === 'fast' ? '#0f0' : '#f00'
                    });
                }, i * 1000);
            }
        }
        
        function update() {
            if (!gameState.running) return;
            
            // Update enemies
            enemies.forEach((enemy, enemyIndex) => {
                if (enemy.pathIndex < path.length - 1) {
                    const current = path[enemy.pathIndex];
                    const next = path[enemy.pathIndex + 1];
                    const dx = next.x - current.x, dy = next.y - current.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    enemy.progress += enemy.speed / distance;
                    
                    if (enemy.progress >= 1) {
                        enemy.progress = 0;
                        enemy.pathIndex++;
                    }
                    
                    enemy.x = current.x + (next.x - current.x) * enemy.progress;
                    enemy.y = current.y + (next.y - current.y) * enemy.progress;
                } else {
                    gameState.lives--;
                    enemies.splice(enemyIndex, 1);
                    if (gameState.lives <= 0) gameOver();
                }
            });
            
            // Tower targeting and shooting
            towers.forEach(tower => {
                tower.lastFire++;
                
                // Find target
                let closestEnemy = null, closestDist = tower.range;
                enemies.forEach(enemy => {
                    const dist = Math.sqrt((tower.x - enemy.x)**2 + (tower.y - enemy.y)**2);
                    if (dist < closestDist) {
                        closestEnemy = enemy;
                        closestDist = dist;
                    }
                });
                
                tower.target = closestEnemy;
                
                // Shoot
                if (tower.target && tower.lastFire >= tower.fireRate) {
                    tower.lastFire = 0;
                    playSound('shoot');
                    
                    projectiles.push({
                        x: tower.x, y: tower.y,
                        targetX: tower.target.x, targetY: tower.target.y,
                        damage: tower.damage, type: tower.type,
                        speed: tower.type === 'missile' ? 3 : 8
                    });
                }
            });
            
            // Update projectiles
            projectiles.forEach((proj, projIndex) => {
                const dx = proj.targetX - proj.x, dy = proj.targetY - proj.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < proj.speed) {
                    // Hit target area
                    enemies.forEach((enemy, enemyIndex) => {
                        const enemyDist = Math.sqrt((proj.targetX - enemy.x)**2 + (proj.targetY - enemy.y)**2);
                        if (enemyDist < 30) {
                            enemy.health -= proj.damage;
                            playSound('hit');
                            
                            // Particles
                            for (let i = 0; i < 8; i++) {
                                particles.push({
                                    x: enemy.x, y: enemy.y,
                                    vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                                    life: 20, color: '#ff6600'
                                });
                            }
                            
                            if (enemy.health <= 0) {
                                gameState.money += enemy.reward;
                                gameState.score += enemy.reward * 10;
                                enemies.splice(enemyIndex, 1);
                            }
                        }
                    });
                    
                    projectiles.splice(projIndex, 1);
                } else {
                    proj.x += (dx / dist) * proj.speed;
                    proj.y += (dy / dist) * proj.speed;
                }
            });
            
            // Update particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                return particle.life > 0;
            });
            
            // Check wave completion
            if (enemies.length === 0) {
                gameState.wave++;
                gameState.money += 50;
                playSound('wave');
                setTimeout(spawnWave, 2000);
            }
            
            updateUI();
        }
        
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw path
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            path.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();
            
            // Draw towers
            towers.forEach(tower => {
                // Range circle when selected
                if (gameState.selectedTower === tower.type) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Tower base
                const colors = { basic: '#666', laser: '#0ff', missile: '#f0f' };
                ctx.fillStyle = colors[tower.type];
                ctx.fillRect(tower.x - 15, tower.y - 15, 30, 30);
                
                // Tower barrel pointing at target
                if (tower.target) {
                    const angle = Math.atan2(tower.target.y - tower.y, tower.target.x - tower.x);
                    ctx.save();
                    ctx.translate(tower.x, tower.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#888';
                    ctx.fillRect(0, -3, 20, 6);
                    ctx.restore();
                }
            });
            
            // Draw enemies
            enemies.forEach(enemy => {
                // Enemy body
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x - 12, enemy.y - 12, 24, 24);
                
                // Health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = '#f00';
                ctx.fillRect(enemy.x - 15, enemy.y - 20, 30, 4);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(enemy.x - 15, enemy.y - 20, 30 * healthPercent, 4);
            });
            
            // Draw projectiles
            projectiles.forEach(proj => {
                const colors = { basic: '#ff0', laser: '#0ff', missile: '#f0f' };
                ctx.fillStyle = colors[proj.type];
                ctx.fillRect(proj.x - 3, proj.y - 3, 6, 6);
                
                if (proj.type === 'laser') {
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(proj.x - 3, proj.y - 3, 6, 6);
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw particles
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 20;
                ctx.fillRect(particle.x, particle.y, 3, 3);
                ctx.globalAlpha = 1;
            });
        }
        
        function gameLoop() {
            update();
            draw();
            if (gameState.running) requestAnimationFrame(gameLoop);
        }
        
        function updateUI() {
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('money').textContent = gameState.money;
            document.getElementById('score').textContent = gameState.score;
        }
        
        function gameOver() {
            gameState.running = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            gameState = { wave: 1, lives: 20, money: 100, score: 0, running: true, selectedTower: null };
            towers = []; enemies = []; projectiles = []; particles = [];
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
            spawnWave();
            gameLoop();
        }
        
        // Initialize
        createPath();
        updateUI();
        spawnWave();
        gameLoop();
    </script>
</body>
</html>
